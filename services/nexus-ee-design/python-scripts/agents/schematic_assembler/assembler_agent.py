"""
Schematic Assembler Agent - Assembles KiCad schematics using real symbols.

Takes a BOM, block diagram, and connections to produce properly laid out
KiCad schematic files with real component symbols.

Uses LLM-first approach via OpenRouter with Claude Opus 4.6 for:
- Pin parsing from KiCad S-expressions
- Wire routing validation
- Connection verification

Author: Nexus EE Design Team
"""

import asyncio
import json
import logging
import os
import re
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import httpx

# Import enhanced wire router (MANDATORY - no fallback)
from agents.wire_router import EnhancedWireRouter, RoutingResult

# Import layout optimizer for intelligent component placement
from agents.layout_optimizer import LayoutOptimizerAgent

logger = logging.getLogger(__name__)


class SchematicAssemblyError(Exception):
    """
    Exception raised when schematic assembly fails.

    This includes:
    - Malformed S-expression output (unbalanced parentheses)
    - Wire routing failures (< 50% connection coverage)
    - Missing symbol definitions
    - Invalid component placement
    """

    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None):
        super().__init__(message)
        self.message = message
        self.details = details or {}

    def __str__(self) -> str:
        if self.details:
            return f"{self.message} | Details: {json.dumps(self.details, indent=2)}"
        return self.message


# LLM configuration — uses centralized llm_provider (respects AI_PROVIDER env var)
# These module-level vars can also be monkey-patched by api_generate_schematic.py
try:
    from llm_provider import get_llm_api_key, get_llm_base_url, log_provider_info as _log_provider
    OPENROUTER_API_KEY = get_llm_api_key()
    OPENROUTER_BASE_URL = get_llm_base_url(chat_completions=True)
except ImportError:
    OPENROUTER_API_KEY = os.environ.get("OPENROUTER_API_KEY", "")
    OPENROUTER_BASE_URL = "https://openrouter.ai/api/v1/chat/completions"
OPENROUTER_MODEL = "claude-opus-4-6"


class PinType(Enum):
    """KiCad pin types."""
    INPUT = "input"
    OUTPUT = "output"
    BIDIRECTIONAL = "bidirectional"
    TRI_STATE = "tri_state"
    PASSIVE = "passive"
    FREE = "free"
    UNSPECIFIED = "unspecified"
    POWER_IN = "power_in"
    POWER_OUT = "power_out"
    OPEN_COLLECTOR = "open_collector"
    OPEN_EMITTER = "open_emitter"
    NO_CONNECT = "no_connect"


class SymbolQuality(Enum):
    """
    Quality classification for resolved symbols.

    Used to track how a symbol was resolved and whether it's production-ready.
    """
    VERIFIED = "verified"        # From official KiCad libraries (highest quality)
    FETCHED = "fetched"          # From external APIs (SnapEDA, UltraLibrarian)
    CACHED = "cached"            # From local cache (previously verified)
    LLM_GENERATED = "generated"  # Generated by LLM (needs manual review)
    PLACEHOLDER = "placeholder"  # Generic fallback (NOT usable in production)


@dataclass
class Pin:
    """Schematic symbol pin."""
    name: str
    number: str
    pin_type: PinType
    position: Tuple[float, float]  # Relative to symbol origin
    orientation: int  # 0=right, 90=up, 180=left, 270=down
    length: float = 2.54


@dataclass
class SymbolInstance:
    """Placed symbol instance in schematic."""
    symbol_id: str  # Reference to lib_symbol
    part_number: str
    reference: str  # U1, R1, C1, etc.
    position: Tuple[float, float]  # mm
    rotation: int  # 0, 90, 180, 270
    mirror: bool = False
    unit: int = 1  # For multi-unit symbols
    value: str = ""
    footprint: str = ""
    uuid: str = field(default_factory=lambda: str(uuid.uuid4()))
    pins: List[Pin] = field(default_factory=list)
    # Symbol quality tracking (added to detect degraded schematics)
    quality: SymbolQuality = SymbolQuality.PLACEHOLDER
    resolution_source: str = ""  # e.g., "kicad_worker", "local_cache", "snapeda"
    resolution_error: Optional[str] = None  # Error message if resolution failed

    def get_absolute_pin_position(self, pin_name: str) -> Optional[Tuple[float, float]]:
        """Get absolute position of a pin."""
        for pin in self.pins:
            if pin.name == pin_name or pin.number == pin_name:
                # Apply rotation and translation
                px, py = pin.position
                if self.rotation == 90:
                    px, py = -py, px
                elif self.rotation == 180:
                    px, py = -px, -py
                elif self.rotation == 270:
                    px, py = py, -px

                return (self.position[0] + px, self.position[1] + py)
        return None


@dataclass
class Wire:
    """Schematic wire segment."""
    start: Tuple[float, float]
    end: Tuple[float, float]
    uuid: str = field(default_factory=lambda: str(uuid.uuid4()))


@dataclass
class Label:
    """Schematic label (net name)."""
    text: str
    position: Tuple[float, float]
    rotation: int = 0
    label_type: str = "label"  # label, global_label, hierarchical_label
    uuid: str = field(default_factory=lambda: str(uuid.uuid4()))


@dataclass
class Junction:
    """Wire junction dot."""
    position: Tuple[float, float]
    uuid: str = field(default_factory=lambda: str(uuid.uuid4()))


@dataclass
class SchematicSheet:
    """Complete schematic sheet."""
    name: str
    filename: str
    symbols: List[SymbolInstance] = field(default_factory=list)
    wires: List[Wire] = field(default_factory=list)
    labels: List[Label] = field(default_factory=list)
    junctions: List[Junction] = field(default_factory=list)
    lib_symbols: Dict[str, str] = field(default_factory=dict)  # symbol_id -> S-expression
    uuid: str = field(default_factory=lambda: str(uuid.uuid4()))
    metadata: Dict[str, Any] = field(default_factory=dict)  # For LLM validation results, etc.


@dataclass
class BOMItem:
    """Bill of materials item."""
    part_number: str
    manufacturer: Optional[str] = None
    reference: Optional[str] = None  # Pre-assigned reference
    quantity: int = 1
    category: str = "Other"
    value: str = ""
    footprint: str = ""
    description: str = ""


@dataclass
class Connection:
    """Net connection between pins."""
    from_ref: str  # e.g., "U1"
    from_pin: str  # e.g., "VCC" or "1"
    to_ref: str
    to_pin: str
    net_name: Optional[str] = None  # Named net, or auto-generated


@dataclass
class BlockDiagram:
    """High-level block diagram structure."""
    blocks: Dict[str, Dict[str, Any]]  # block_name -> {components: [], external_pins: []}
    connections: List[Dict[str, str]]  # Inter-block connections


class SchematicAssemblerAgent:
    """
    Assembles KiCad schematics using real symbols.

    Pipeline:
    1. Resolve symbols for all BOM items
    2. Plan hierarchical sheet structure
    3. Place components with signal-flow optimization
    4. Route wires using Manhattan routing
    5. Add labels, junctions, power flags
    6. Generate KiCad S-expression output
    """

    GRID_UNIT = 2.54  # mm (100 mil standard KiCad grid)
    DEFAULT_SHEET_SIZE = (297, 210)  # A4 landscape in mm

    # Reference designator prefixes by category
    REF_PREFIXES = {
        "MCU": "U",
        "IC": "U",
        "MOSFET": "Q",
        "BJT": "Q",
        "Transistor": "Q",
        "Gate_Driver": "U",
        "OpAmp": "U",
        "Amplifier": "U",
        "Capacitor": "C",
        "Resistor": "R",
        "Inductor": "L",
        "Diode": "D",
        "LED": "D",
        "Connector": "J",
        "Power": "U",
        "Regulator": "U",
        "Crystal": "Y",
        "Fuse": "F",
        "Relay": "K",
        "Transformer": "T",
        "Other": "U"
    }

    def __init__(self, symbol_fetcher: Any = None, graphrag_client: Any = None):
        """
        Initialize the assembler with LLM-first approach.

        Uses Claude Opus 4.6 via OpenRouter for:
        - Pin parsing from KiCad S-expressions
        - Wire routing validation
        - Connection verification

        Args:
            symbol_fetcher: SymbolFetcherAgent for getting real symbols
            graphrag_client: GraphRAG client for symbol lookup
        """
        self.symbol_fetcher = symbol_fetcher
        self.graphrag = graphrag_client
        self.ref_counters: Dict[str, int] = {}

        # LLM-first: OpenRouter client for Claude Opus 4.6
        self._openrouter_api_key = OPENROUTER_API_KEY
        self._http_client: Optional[httpx.AsyncClient] = None
        self._pin_parse_cache: Dict[str, List[Pin]] = {}  # Cache parsed pins by sexp hash
        if not self._openrouter_api_key:
            logger.warning(
                "OPENROUTER_API_KEY not set - LLM-based pin parsing unavailable. "
                "Set OPENROUTER_API_KEY environment variable for AI-first approach."
            )
        else:
            logger.info("LLM-first mode enabled via OpenRouter (Claude Opus 4.6)")

        # Initialize enhanced wire router (MANDATORY)
        self.enhanced_router = EnhancedWireRouter()
        logger.info("Enhanced Wire Router initialized")

        # Initialize layout optimizer for intelligent component placement
        self.layout_optimizer = LayoutOptimizerAgent()
        logger.info("Layout Optimizer initialized")

    def _get_next_reference(self, category: str) -> str:
        """Get next available reference designator."""
        prefix = self.REF_PREFIXES.get(category, "U")
        count = self.ref_counters.get(prefix, 0) + 1
        self.ref_counters[prefix] = count
        return f"{prefix}{count}"

    def _determine_symbol_quality(
        self,
        source: str,
        metadata: Dict[str, Any]
    ) -> SymbolQuality:
        """
        Determine symbol quality based on resolution source and metadata.

        Args:
            source: The source that provided the symbol (e.g., "kicad_worker_internal")
            metadata: Additional metadata about the symbol resolution

        Returns:
            SymbolQuality enum indicating symbol reliability
        """
        # Check for explicit placeholder flag
        if metadata.get("is_placeholder", False):
            return SymbolQuality.PLACEHOLDER

        # Check for explicit generated flag (from LLM)
        if metadata.get("is_generic", False):
            return SymbolQuality.PLACEHOLDER

        # Map sources to quality levels
        source_quality_map = {
            "kicad_local_install": SymbolQuality.VERIFIED,
            "kicad_worker_internal": SymbolQuality.VERIFIED,
            "kicad_official": SymbolQuality.VERIFIED,
            "local_cache": SymbolQuality.CACHED,
            "snapeda": SymbolQuality.FETCHED,
            "ultralibrarian": SymbolQuality.FETCHED,
            "ti_webench": SymbolQuality.FETCHED,
            "stm_cube": SymbolQuality.FETCHED,
            "llm_generated": SymbolQuality.LLM_GENERATED,
            "generated": SymbolQuality.PLACEHOLDER,
        }

        # Normalize source string
        source_lower = source.lower().replace("-", "_")
        quality = source_quality_map.get(source_lower, SymbolQuality.PLACEHOLDER)

        # Log warning for placeholder-quality symbols
        if quality == SymbolQuality.PLACEHOLDER:
            logger.warning(
                f"Symbol resolved as PLACEHOLDER (source: {source}, "
                f"metadata: {metadata.get('reason', 'unknown')})"
            )

        return quality

    async def assemble_schematic(
        self,
        bom: List[BOMItem],
        block_diagram: Optional[BlockDiagram] = None,
        connections: Optional[List[Connection]] = None,
        design_name: str = "schematic"
    ) -> List[SchematicSheet]:
        """
        Main entry point for schematic assembly.

        Args:
            bom: Bill of materials
            block_diagram: Optional block diagram structure
            connections: Net connections between components
            design_name: Name for the schematic

        Returns:
            List of SchematicSheet objects
        """
        logger.info(f"Assembling schematic '{design_name}' with {len(bom)} components")

        # Reset reference counters
        self.ref_counters = {}

        # Step 1: Resolve all symbols
        resolved_symbols = await self._resolve_symbols(bom)

        # Step 2: Plan sheet hierarchy
        if block_diagram:
            sheets = self._plan_hierarchical_sheets(block_diagram, bom, resolved_symbols)
        else:
            sheets = [SchematicSheet(
                name=design_name,
                filename=f"{design_name}.kicad_sch"
            )]

        # Step 3: Assign components to sheets and create instances
        self._assign_components(sheets, bom, resolved_symbols)

        # Step 4: Place components using Layout Optimizer (with connectivity analysis)
        for sheet in sheets:
            self._place_components_optimized(sheet, connections or [], bom)

        # Step 5: Route wires using Enhanced Wire Router
        if connections:
            for sheet in sheets:
                await self._route_wires(sheet, connections)

        # Step 6: Add power symbols and labels
        for sheet in sheets:
            self._add_power_symbols(sheet)

        # Step 7: Validate component count against BOM
        actual_count = sum(len(sheet.symbols) for sheet in sheets)
        expected_count = len(bom)
        if actual_count < expected_count:
            placed_parts = {s.part_number for sheet in sheets for s in sheet.symbols}
            bom_parts = {item.part_number for item in bom}
            missing = bom_parts - placed_parts
            logger.error(
                f"ASSEMBLY VALIDATION: Only {actual_count}/{expected_count} components placed. "
                f"Missing parts: {sorted(missing)}"
            )
            # Log as error but don't raise — let the pipeline continue so visual
            # validation can detect and potentially fix placement issues
        else:
            logger.info(
                f"ASSEMBLY VALIDATION: All {actual_count}/{expected_count} components placed successfully"
            )

        logger.info(f"Assembly complete: {len(sheets)} sheet(s)")
        return sheets

    async def _resolve_symbols(
        self,
        bom: List[BOMItem]
    ) -> Dict[str, Dict[str, Any]]:
        """Resolve symbols for all BOM items."""
        resolved = {}

        for item in bom:
            if item.part_number in resolved:
                continue

            symbol_data = None

            # Try symbol fetcher first
            if self.symbol_fetcher:
                try:
                    fetched = await self.symbol_fetcher.fetch_symbol(
                        item.part_number,
                        item.manufacturer,
                        item.category
                    )
                    # Extract actual symbol name DETERMINISTICALLY first (no LLM)
                    actual_symbol_name = self._extract_symbol_name_deterministic(fetched.symbol_sexp)
                    if not actual_symbol_name:
                        # Deterministic extraction failed — try LLM as fallback
                        actual_symbol_name = await self._extract_symbol_name(fetched.symbol_sexp)
                    if not actual_symbol_name:
                        logger.warning(
                            f"Could not extract symbol name from fetched sexp for {item.part_number} "
                            f"(sexp length={len(fetched.symbol_sexp)}). Using part_number as name."
                        )
                        actual_symbol_name = fetched.part_number
                    symbol_data = {
                        "sexp": fetched.symbol_sexp,
                        "symbol_name": actual_symbol_name,
                        "pins": self._parse_pins_deterministic(fetched.symbol_sexp),
                        "source": fetched.source.value,
                        "metadata": fetched.metadata
                    }
                    logger.info(
                        f"Resolved {item.part_number} -> symbol '{actual_symbol_name}' "
                        f"from {fetched.source.value} ({len(symbol_data['pins'])} pins)"
                    )
                except Exception as e:
                    logger.warning(f"Symbol fetch failed for {item.part_number}: {e}")

            # Fallback: create generic symbol
            if not symbol_data:
                symbol_data = self._create_generic_symbol(item)

            resolved[item.part_number] = symbol_data

        return resolved

    def _extract_symbol_name_deterministic(self, sexp: str) -> Optional[str]:
        """
        Extract the primary symbol name from a KiCad S-expression deterministically.

        Parses the sexp directly using regex — no LLM dependency. Finds the first
        (symbol "NAME" ...) that is NOT a sub-symbol (i.e., doesn't end with _N_N suffix).

        This is the PRIMARY extraction path — fast, reliable, deterministic.
        """
        if not sexp or not sexp.strip():
            return None

        # Find all (symbol "NAME" patterns
        pattern = re.compile(r'\(symbol\s+"([^"]+)"')
        for match in pattern.finditer(sexp):
            name = match.group(1)
            # Skip sub-symbols (e.g., "R_0_1", "STM32G431CBTxZ_1_1")
            if not re.search(r'_\d+_\d+$', name):
                return name
        return None

    def _rename_symbol_in_sexp(self, sexp: str, old_name: str, new_name: str) -> str:
        """
        Rename a symbol and all its sub-symbols in a KiCad S-expression.

        Replaces:
          (symbol "OLD_NAME" ...) → (symbol "NEW_NAME" ...)
          (symbol "OLD_NAME_0_1" ...) → (symbol "NEW_NAME_0_1" ...)
          (symbol "OLD_NAME_1_1" ...) → (symbol "NEW_NAME_1_1" ...)

        This is a safety net for when a fetched symbol's internal name doesn't
        match the expected lib_id in the schematic.
        """
        # Escape for regex
        escaped_old = re.escape(old_name)
        # Replace main symbol and all sub-symbols (e.g., R_0_1 → PARTNUM_0_1)
        result = re.sub(
            rf'\(symbol\s+"{escaped_old}((?:_\d+_\d+)?)"',
            lambda m: f'(symbol "{new_name}{m.group(1)}"',
            sexp
        )
        return result

    async def _extract_symbol_name(self, sexp: str) -> Optional[str]:
        """
        Extract the actual symbol name from a KiCad S-expression using LLM.

        AI-first approach: Uses Claude Opus 4.6 to intelligently identify the
        primary symbol name, excluding sub-symbol suffixes like _0_1 or _1_1.
        """
        if not self._openrouter_api_key:
            logger.warning("OpenRouter API key not set - cannot extract symbol name via LLM")
            return None

        # Initialize HTTP client if needed
        if self._http_client is None:
            self._http_client = httpx.AsyncClient(timeout=30.0)

        prompt = f"""You are a KiCad schematic symbol parser. Extract the PRIMARY symbol name from this S-expression.

Rules:
1. Find the main (symbol "NAME" ...) definition
2. EXCLUDE sub-symbols that end with suffixes like _0_1, _1_1, _2_1, etc.
3. Return ONLY the symbol name as a plain string, nothing else
4. If no valid symbol name is found, return "null" (without quotes)

S-expression to parse:
```
{sexp[:3000]}
```

Return ONLY the symbol name (no quotes, no explanation):"""

        try:
            response = await self._http_client.post(
                OPENROUTER_BASE_URL,
                headers={
                    "Authorization": f"Bearer {self._openrouter_api_key}",
                    "Content-Type": "application/json",
                    "HTTP-Referer": "https://nexus.adverant.com",
                    "X-Title": "Nexus EE Design - Symbol Name Extraction"
                },
                json={
                    "model": OPENROUTER_MODEL,
                    "messages": [
                        {"role": "system", "content": "You are a precise KiCad S-expression parser. Return only the requested data, no explanations."},
                        {"role": "user", "content": prompt}
                    ],
                    "temperature": 0.0,
                    "max_tokens": 100
                }
            )
            response.raise_for_status()
            result = response.json()

            content = result["choices"][0]["message"]["content"].strip()
            # Clean up any quotes that might have been added
            content = content.strip('"\'').strip()

            if content.lower() == "null" or not content:
                return None

            logger.debug(f"LLM extracted symbol name: {content}")
            return content

        except Exception as e:
            logger.error(f"LLM symbol name extraction failed: {e}")
            return None

    def _parse_pins_deterministic(self, sexp: str) -> List[Pin]:
        """
        Parse pins from KiCad S-expression deterministically using regex.

        No LLM dependency — works offline, instant, and deterministic.
        Handles KiCad v6/v7/v8 pin formats.

        Args:
            sexp: KiCad symbol S-expression string

        Returns:
            List of Pin objects extracted from the S-expression.
        """
        pins = []

        # KiCad pin type mapping
        type_map = {
            "input": PinType.INPUT,
            "output": PinType.OUTPUT,
            "bidirectional": PinType.BIDIRECTIONAL,
            "tri_state": PinType.TRI_STATE,
            "passive": PinType.PASSIVE,
            "free": PinType.FREE,
            "unspecified": PinType.UNSPECIFIED,
            "power_in": PinType.POWER_IN,
            "power_out": PinType.POWER_OUT,
            "open_collector": PinType.OPEN_COLLECTOR,
            "open_emitter": PinType.OPEN_EMITTER,
            "no_connect": PinType.NO_CONNECT,
        }

        # Regex to find pin blocks: (pin TYPE STYLE (at X Y [ANGLE]) ... (name "NAME") ... (number "NUM"))
        # Using DOTALL so . matches newlines within a pin block
        pin_block_pattern = re.compile(
            r'\(pin\s+(\w+)\s+\w+'     # (pin TYPE STYLE
            r'(.*?)'                     # ... everything inside pin block ...
            r'\)',                        # closing paren
            re.DOTALL
        )

        # Sub-patterns for fields within a pin block
        at_pattern = re.compile(r'\(at\s+([-\d.]+)\s+([-\d.]+)(?:\s+([-\d.]+))?\)')
        name_pattern = re.compile(r'\(name\s+"([^"]*)"')
        number_pattern = re.compile(r'\(number\s+"([^"]*)"')
        length_pattern = re.compile(r'\(length\s+([-\d.]+)\)')

        # Find all pin blocks by tracking balanced parentheses
        i = 0
        while i < len(sexp):
            # Find next (pin
            pin_start = sexp.find('(pin ', i)
            if pin_start == -1:
                break

            # Find the matching closing paren by counting nesting
            depth = 0
            j = pin_start
            while j < len(sexp):
                if sexp[j] == '(':
                    depth += 1
                elif sexp[j] == ')':
                    depth -= 1
                    if depth == 0:
                        break
                j += 1

            if depth != 0:
                # Unbalanced — skip
                i = pin_start + 5
                continue

            pin_block = sexp[pin_start:j + 1]
            i = j + 1

            # Extract pin type (first word after "pin ")
            pin_type_match = re.match(r'\(pin\s+(\w+)', pin_block)
            if not pin_type_match:
                continue
            pin_type_str = pin_type_match.group(1).lower()
            pin_type = type_map.get(pin_type_str, PinType.UNSPECIFIED)

            # Extract position
            at_match = at_pattern.search(pin_block)
            if not at_match:
                continue
            x = float(at_match.group(1))
            y = float(at_match.group(2))
            angle = float(at_match.group(3)) if at_match.group(3) else 0.0

            # Extract name
            name_match = name_pattern.search(pin_block)
            pin_name = name_match.group(1) if name_match else ""

            # Extract number
            number_match = number_pattern.search(pin_block)
            pin_number = number_match.group(1) if number_match else ""

            # Extract length
            length_match = length_pattern.search(pin_block)
            pin_length = float(length_match.group(1)) if length_match else 2.54

            if pin_name or pin_number:  # Must have at least name or number
                pins.append(Pin(
                    name=pin_name,
                    number=pin_number,
                    pin_type=pin_type,
                    position=(x, y),
                    orientation=int(angle),
                    length=pin_length,
                ))

        return pins

    async def _parse_pins_from_sexp(self, sexp: str) -> List[Pin]:
        """
        Parse pin information from KiCad S-expression.

        Uses deterministic regex parser as primary path (instant, no API key needed).
        Falls back to LLM only if deterministic parser returns empty and API key is set.

        Args:
            sexp: KiCad symbol S-expression string

        Returns:
            List of Pin objects.
            Cached for subsequent calls with the same sexp.
        """
        # Cache key based on sexp content hash
        import hashlib
        cache_key = hashlib.md5(sexp.encode()).hexdigest()

        # Return cached result if available
        if cache_key in self._pin_parse_cache:
            logger.debug(f"Pin parse cache hit for {cache_key[:8]}")
            return self._pin_parse_cache[cache_key]

        # PRIMARY: Deterministic S-expression parser (no LLM needed)
        pins = self._parse_pins_deterministic(sexp)
        if pins:
            self._pin_parse_cache[cache_key] = pins
            logger.info(f"Deterministic parser extracted {len(pins)} pins (cached as {cache_key[:8]})")
            return pins

        # FALLBACK: LLM-based parsing (only if deterministic failed AND API key available)
        if not self._openrouter_api_key:
            logger.warning(
                "Deterministic pin parser found 0 pins and LLM unavailable "
                "(OPENROUTER_API_KEY not set). Returning empty pin list."
            )
            return []

        logger.info("Deterministic parser found 0 pins — falling back to LLM...")

        # Initialize HTTP client if needed
        if self._http_client is None:
            self._http_client = httpx.AsyncClient(timeout=60.0)

        # Construct LLM prompt for pin extraction
        prompt = f"""You are a KiCad schematic symbol parser. Extract ALL pin definitions from this KiCad S-expression.

For each pin, extract:
- name: The pin name (from the (name "...") field)
- number: The pin number (from the (number "...") field)
- type: The pin type (input, output, bidirectional, passive, power_in, power_out, etc.)
- x: X position from (at X Y angle)
- y: Y position from (at X Y angle)
- angle: Orientation angle from (at X Y angle)

Return ONLY a JSON array of pin objects, no explanation:
[
  {{"name": "VCC", "number": "1", "type": "power_in", "x": -7.62, "y": 5.08, "angle": 0}},
  ...
]

If no pins are found, return an empty array: []

IMPORTANT: You MUST extract ALL pins, even if there are 48+ pins. Do not truncate or summarize.

KiCad S-expression:
```
{sexp[:40000]}
```

JSON array of pins:"""

        try:
            response = await self._http_client.post(
                OPENROUTER_BASE_URL,
                headers={
                    "Authorization": f"Bearer {self._openrouter_api_key}",
                    "Content-Type": "application/json",
                    "HTTP-Referer": "https://nexus.adverant.com",
                    "X-Title": "Nexus EE Design - Pin Parser"
                },
                json={
                    "model": OPENROUTER_MODEL,
                    "messages": [
                        {
                            "role": "user",
                            "content": prompt
                        }
                    ],
                    "temperature": 0.0,  # Deterministic parsing
                    "max_tokens": 16384  # Increased for symbols with 48+ pins
                }
            )

            if response.status_code != 200:
                logger.error(f"OpenRouter API error: {response.status_code} - {response.text}")
                return []

            result = response.json()
            content = result.get("choices", [{}])[0].get("message", {}).get("content", "[]")

            # Extract JSON from response (handle markdown code blocks)
            if "```json" in content:
                content = content.split("```json")[1].split("```")[0].strip()
            elif "```" in content:
                content = content.split("```")[1].split("```")[0].strip()

            # Parse JSON response
            pin_data = json.loads(content)

            # Pin type mapping
            type_map = {
                "input": PinType.INPUT,
                "output": PinType.OUTPUT,
                "bidirectional": PinType.BIDIRECTIONAL,
                "tri_state": PinType.TRI_STATE,
                "passive": PinType.PASSIVE,
                "free": PinType.FREE,
                "unspecified": PinType.UNSPECIFIED,
                "power_in": PinType.POWER_IN,
                "power_out": PinType.POWER_OUT,
                "open_collector": PinType.OPEN_COLLECTOR,
                "open_emitter": PinType.OPEN_EMITTER,
                "no_connect": PinType.NO_CONNECT,
            }

            pins = []
            for p in pin_data:
                pin_type = type_map.get(p.get("type", "unspecified").lower(), PinType.UNSPECIFIED)
                pins.append(Pin(
                    name=str(p.get("name", "")),
                    number=str(p.get("number", "")),
                    pin_type=pin_type,
                    position=(float(p.get("x", 0)), float(p.get("y", 0))),
                    orientation=int(p.get("angle", 0))
                ))

            # Cache the result
            self._pin_parse_cache[cache_key] = pins
            logger.info(f"LLM parsed {len(pins)} pins from symbol (cached as {cache_key[:8]})")
            return pins

        except json.JSONDecodeError as e:
            logger.error(f"LLM returned invalid JSON for pin parsing: {e}")
            return []
        except Exception as e:
            logger.error(f"LLM pin parsing failed: {e}")
            return []

    def _create_generic_symbol(self, item: BOMItem) -> Dict[str, Any]:
        """Create a generic symbol for items without real symbols.

        Note: For generated symbols, we directly create Pin objects since we know
        the exact structure. LLM parsing is reserved for external/unknown data.
        """
        prefix = self.REF_PREFIXES.get(item.category, "U")

        # Determine number of pins based on category
        pin_count = {
            "Resistor": 2,
            "Capacitor": 2,
            "Inductor": 2,
            "Diode": 2,
            "LED": 2,
            "MOSFET": 3,
            "BJT": 3,
            "Crystal": 2,
            "Fuse": 2,
        }.get(item.category, 4)

        # Generate generic symbol S-expression
        pins_sexp = []
        pin_positions = self._calculate_pin_positions(pin_count)

        # Directly create Pin objects (no need to parse what we just generated)
        pins: List[Pin] = []

        for i, (x, y, angle) in enumerate(pin_positions):
            pin_name = f"P{i+1}"
            pins_sexp.append(f'''      (pin passive line (at {x} {y} {angle}) (length 2.54)
        (name "{pin_name}" (effects (font (size 1.27 1.27))))
        (number "{i+1}" (effects (font (size 1.27 1.27))))
      )''')
            # Create Pin object directly
            pins.append(Pin(
                name=pin_name,
                number=str(i + 1),
                pin_type=PinType.PASSIVE,
                position=(x, y),
                orientation=angle
            ))

        pins_str = "\n".join(pins_sexp)

        # Rectangle size based on pin count
        rect_height = max(5.08, (pin_count // 2 + 1) * 2.54)
        rect_width = 7.62

        sexp = f'''(kicad_symbol_lib (version 20231120) (generator nexus_ee_design)
  (symbol "{item.part_number}" (in_bom yes) (on_board yes)
    (property "Reference" "{prefix}" (at 0 {rect_height/2 + 2.54} 0)
      (effects (font (size 1.27 1.27)))
    )
    (property "Value" "{item.value or item.part_number}" (at 0 {-rect_height/2 - 2.54} 0)
      (effects (font (size 1.27 1.27)))
    )
    (property "Footprint" "{item.footprint}" (at 0 0 0)
      (effects (font (size 1.27 1.27)) hide)
    )
    (property "Datasheet" "~" (at 0 0 0)
      (effects (font (size 1.27 1.27)) hide)
    )
    (symbol "{item.part_number}_0_1"
      (rectangle (start {-rect_width/2} {rect_height/2}) (end {rect_width/2} {-rect_height/2})
        (stroke (width 0.254) (type default))
        (fill (type background))
      )
    )
    (symbol "{item.part_number}_1_1"
{pins_str}
    )
  )
)'''

        return {
            "sexp": sexp,
            "symbol_name": item.part_number,  # Generic symbols use part number as name
            "pins": pins,  # Directly use created Pin objects
            "source": "generated",
            "metadata": {"is_generic": True}
        }

    def _calculate_pin_positions(
        self,
        pin_count: int
    ) -> List[Tuple[float, float, int]]:
        """Calculate pin positions for a generic symbol."""
        positions = []
        half = pin_count // 2
        spacing = 2.54

        # Left side pins (input convention)
        for i in range(half):
            y = (half - 1) * spacing / 2 - i * spacing
            positions.append((-7.62, y, 0))

        # Right side pins (output convention)
        for i in range(pin_count - half):
            y = (pin_count - half - 1) * spacing / 2 - i * spacing
            positions.append((7.62, y, 180))

        return positions

    def _plan_hierarchical_sheets(
        self,
        block_diagram: BlockDiagram,
        bom: List[BOMItem],
        symbols: Dict[str, Dict]
    ) -> List[SchematicSheet]:
        """Plan hierarchical sheet structure from block diagram."""
        sheets = []

        # Root sheet
        root = SchematicSheet(
            name="Root",
            filename="root.kicad_sch"
        )
        sheets.append(root)

        # Create sheet for each block
        for block_name, block_data in block_diagram.blocks.items():
            sheet = SchematicSheet(
                name=block_name,
                filename=f"{block_name.lower().replace(' ', '_')}.kicad_sch"
            )
            sheets.append(sheet)

        return sheets

    def _assign_components(
        self,
        sheets: List[SchematicSheet],
        bom: List[BOMItem],
        symbols: Dict[str, Dict]
    ):
        """Assign components to sheets and create symbol instances."""
        # For now, put all components on first sheet
        # TODO: Implement proper multi-sheet assignment based on block diagram
        main_sheet = sheets[0]

        for item in bom:
            symbol_data = symbols.get(item.part_number, {})

            # Get the actual symbol name (may differ from part number due to fuzzy matching)
            actual_symbol_name = symbol_data.get("symbol_name", item.part_number)

            # Get or assign reference
            if item.reference:
                reference = item.reference
            else:
                reference = self._get_next_reference(item.category)

            # Determine symbol quality from metadata
            metadata = symbol_data.get("metadata", {})
            source = symbol_data.get("source", "unknown")
            quality = self._determine_symbol_quality(source, metadata)

            instance = SymbolInstance(
                symbol_id=actual_symbol_name,  # Use actual symbol name for lib_id
                part_number=item.part_number,  # Keep original part number for BOM
                reference=reference,
                position=(0, 0),  # Will be set during placement
                rotation=0,
                value=item.value or item.part_number,
                footprint=item.footprint,
                pins=symbol_data.get("pins", []),
                quality=quality,
                resolution_source=source,
                resolution_error=metadata.get("error") if quality == SymbolQuality.PLACEHOLDER else None
            )

            main_sheet.symbols.append(instance)

            # Add lib symbol if not already present (keyed by actual symbol name)
            if actual_symbol_name not in main_sheet.lib_symbols:
                main_sheet.lib_symbols[actual_symbol_name] = symbol_data.get("sexp", "")

        # POST-ASSIGNMENT VALIDATION: Ensure every symbol instance's lib_id has a definition
        referenced_ids = set(s.symbol_id for s in main_sheet.symbols)
        defined_ids = set(main_sheet.lib_symbols.keys())
        missing_ids = referenced_ids - defined_ids
        if missing_ids:
            logger.error(
                f"SYMBOL INTEGRITY CHECK FAILED: {len(missing_ids)} lib_ids referenced "
                f"but not defined: {sorted(missing_ids)}"
            )
            # Generate placeholder definitions for missing symbols
            for mid in missing_ids:
                logger.warning(f"Generating emergency placeholder for missing lib_symbol: {mid}")
                placeholder_sexp = self._create_emergency_lib_symbol(mid)
                main_sheet.lib_symbols[mid] = placeholder_sexp
        else:
            logger.info(
                f"Symbol integrity check PASSED: {len(referenced_ids)} unique lib_ids, "
                f"all have definitions"
            )

    def _create_emergency_lib_symbol(self, symbol_id: str) -> str:
        """Create a minimal lib_symbol sexp for an undefined symbol_id.

        This is a last-resort safety net — ensures kicad-cli never encounters
        an undefined lib_id reference.
        """
        safe_id = symbol_id.replace('"', '\\"')
        return f'''(kicad_symbol_lib (version 20231120) (generator nexus_ee_design)
  (symbol "{safe_id}" (in_bom yes) (on_board yes)
    (property "Reference" "?" (at 0 3.81 0)
      (effects (font (size 1.27 1.27)))
    )
    (property "Value" "{safe_id}" (at 0 -3.81 0)
      (effects (font (size 1.27 1.27)))
    )
    (property "Footprint" "" (at 0 0 0)
      (effects (font (size 1.27 1.27)) hide)
    )
    (property "Datasheet" "~" (at 0 0 0)
      (effects (font (size 1.27 1.27)) hide)
    )
    (symbol "{safe_id}_0_1"
      (rectangle (start -5.08 5.08) (end 5.08 -5.08)
        (stroke (width 0.254) (type default))
        (fill (type background))
      )
    )
    (symbol "{safe_id}_1_1"
      (pin passive line (at -7.62 2.54 0) (length 2.54)
        (name "1" (effects (font (size 1.27 1.27))))
        (number "1" (effects (font (size 1.27 1.27))))
      )
      (pin passive line (at 7.62 2.54 180) (length 2.54)
        (name "2" (effects (font (size 1.27 1.27))))
        (number "2" (effects (font (size 1.27 1.27))))
      )
    )
  )
)'''

    def _place_components_optimized(
        self,
        sheet: SchematicSheet,
        connections: List[Connection],
        bom: List[BOMItem]
    ):
        """
        Place components using Layout Optimizer with signal-flow optimization.

        Uses the LayoutOptimizerAgent for professional placement:
        - Zone-based placement (power/input/processing/output/passive)
        - Signal flow left-to-right analysis
        - Bypass capacitor placement near ICs
        - Grid alignment and spacing verification
        - IPC-2221/IEEE 315 compliance
        """
        logger.info(f"Placing {len(sheet.symbols)} components using Layout Optimizer")

        # Build BOM dict for category lookup
        bom_dict = []
        for item in bom:
            bom_dict.append({
                "reference": None,  # Will be matched by part_number
                "part_number": item.part_number,
                "category": item.category,
                "manufacturer": item.manufacturer,
                "value": item.value,
            })

        # Match BOM items to symbol references
        for symbol in sheet.symbols:
            for bom_item in bom_dict:
                if bom_item["part_number"] == symbol.part_number:
                    bom_item["reference"] = symbol.reference
                    break

        # Filter to only items with references assigned
        bom_with_refs = [b for b in bom_dict if b.get("reference")]

        # Run Layout Optimizer
        result = self.layout_optimizer.optimize_layout(
            symbols=sheet.symbols,
            connections=connections,
            bom=bom_with_refs
        )

        # Log optimization results
        logger.info(
            f"Layout optimization: {len(result.improvements)} improvements, "
            f"{len(result.violations)} violations, "
            f"{result.grid_corrections} grid corrections"
        )

        if result.violations:
            for v in result.violations[:5]:  # Log first 5 violations
                logger.warning(f"Layout violation: {v}")

        logger.info(f"Placed {len(sheet.symbols)} components on sheet '{sheet.name}'")

    async def _route_wires(self, sheet: SchematicSheet, connections: List[Connection]):
        """Route wires between connected pins using Enhanced Wire Router.

        Features:
        - Professional Manhattan routing with IPC compliance
        - Power rail optimization (VCC top, GND bottom)
        - Bus routing for parallel signals
        - 4-way junction avoidance
        - Grid-aligned wire placement
        """
        # Build symbol lookup
        symbol_map = {s.reference: s for s in sheet.symbols}

        # Always use enhanced router (mandatory)
        await self._route_wires_enhanced(sheet, connections, symbol_map)

    async def _route_wires_enhanced(
        self,
        sheet: SchematicSheet,
        connections: List[Connection],
        symbol_map: Dict[str, SymbolInstance]
    ):
        """
        Route wires using Enhanced Wire Router with comprehensive validation.

        Includes:
        - Pre-routing validation (structural checks on pins/positions)
        - Post-routing validation (verify wires were generated)
        - LLM-based semantic validation (verify connections make sense)
        """
        logger.info("Using Enhanced Wire Router for professional routing")

        # ========================================
        # PRE-ROUTING VALIDATION
        # ========================================

        # Build data structures for enhanced router with validation
        conn_dicts = []
        component_positions = {}
        pin_positions = {}
        pins_found = 0
        pins_missing = 0
        symbols_without_pins = []

        for symbol in sheet.symbols:
            component_positions[symbol.reference] = symbol.position
            pin_positions[symbol.reference] = {}

            # VALIDATION: Check if symbol has pins
            if not symbol.pins:
                symbols_without_pins.append(f"{symbol.reference} ({symbol.part_number})")
                logger.warning(
                    f"Symbol {symbol.reference} ({symbol.part_number}) has NO PINS - "
                    f"wire routing will fail for connections to this component"
                )
                continue

            for pin in symbol.pins:
                abs_pos = symbol.get_absolute_pin_position(pin.name)
                if abs_pos:
                    pin_positions[symbol.reference][pin.name] = abs_pos
                    # Also add by pin number
                    pin_positions[symbol.reference][pin.number] = abs_pos
                    pins_found += 1
                else:
                    pins_missing += 1

        # VALIDATION: Fail fast if no pins found
        if pins_found == 0:
            error_msg = (
                f"CRITICAL: No pin positions found for {len(sheet.symbols)} components. "
                f"Wire routing cannot proceed. Check symbol pin parsing."
            )
            logger.error(error_msg)
            if symbols_without_pins:
                logger.error(f"Symbols without pins: {', '.join(symbols_without_pins[:10])}")
            raise ValueError(error_msg)

        logger.info(f"Pin validation: {pins_found} found, {pins_missing} missing, {len(symbols_without_pins)} symbols without pins")

        # Build connection list with validation
        # Handle power connections separately (they use virtual refs like "PWR", "GND")
        POWER_REFS = {"PWR", "GND", "POWER", "GROUND", "VCC", "VDD", "VSS"}
        valid_connections = 0
        invalid_connections = []
        power_labels_added = []
        power_wires_added = []  # Track wires to power symbols

        # Helper to find pin with normalization (handles "PF0-OSC_IN" -> "PF0" matching)
        # MUST be defined before power connection handling
        def find_pin_position(ref: str, pin_name: str) -> tuple:
            """Find pin position, trying multiple name formats and power net equivalents."""
            ref_pins = pin_positions.get(ref, {})

            # Power net equivalents - VCC/VDD/3V3 are interchangeable, GND/VSS/GROUND are interchangeable
            POWER_EQUIVALENTS = {
                "VCC": ["VDD", "VDD1", "VDD2", "VDD3", "VDDA", "VDDIO", "3V3", "5V", "+3.3V", "+5V"],
                "VDD": ["VCC", "VDD1", "VDD2", "VDD3", "VDDA", "VDDIO", "3V3", "5V"],
                "GND": ["VSS", "VSS1", "VSS2", "VSSA", "GROUND", "DGND", "AGND", "GND1", "GND2"],
                "VSS": ["GND", "VSS1", "VSS2", "VSSA", "GROUND", "DGND", "AGND"],
                "VBAT": ["VBAT", "BAT", "VBACKUP"],
            }

            # Try exact match first
            if pin_name in ref_pins:
                return ref_pins[pin_name], pin_name

            # Try stripping suffixes like "-OSC_IN", "-Pad1", "_A"
            base_name = pin_name.split('-')[0].split('_')[0]
            if base_name in ref_pins:
                return ref_pins[base_name], base_name

            # Try uppercase/lowercase variations
            for variant in [pin_name.upper(), pin_name.lower(), base_name.upper(), base_name.lower()]:
                if variant in ref_pins:
                    return ref_pins[variant], variant

            # Try power net equivalents
            pin_upper = pin_name.upper()
            for canonical, equivalents in POWER_EQUIVALENTS.items():
                if pin_upper == canonical or pin_upper in equivalents:
                    # Try all equivalents
                    for equiv in [canonical] + equivalents:
                        if equiv in ref_pins:
                            return ref_pins[equiv], equiv
                        if equiv.lower() in ref_pins:
                            return ref_pins[equiv.lower()], equiv.lower()

            # Try partial match (pin_name starts with or contains symbol pin)
            for sym_pin, pos in ref_pins.items():
                if sym_pin in pin_name or pin_name in sym_pin:
                    return pos, sym_pin

            return None, None

        # Track power symbol positions for wire routing
        power_symbol_positions = {}  # {"VCC": (x, y), "GND": (x, y)}

        for conn in connections:
            from_ref = conn.from_ref
            to_ref = conn.to_ref

            # Handle power connections specially
            is_power_from = from_ref.upper() in POWER_REFS
            is_power_to = to_ref.upper() in POWER_REFS

            if is_power_from or is_power_to:
                # Power connection - find the component pin position using normalization
                if is_power_to and from_ref in pin_positions:
                    # Connection from component to power rail (e.g., U1.VDD -> PWR.VCC)
                    pin_pos, resolved_pin = find_pin_position(from_ref, conn.from_pin)
                    if pin_pos:
                        label_text = conn.net_name or conn.to_pin or "VCC"
                        # Place power label at the pin position
                        sheet.labels.append(Label(
                            text=label_text,
                            position=(pin_pos[0] + 2.54, pin_pos[1]),
                            rotation=0,
                            label_type="global_label"
                        ))
                        power_labels_added.append(f"{from_ref}.{conn.from_pin} -> {label_text}")
                    else:
                        logger.warning(f"Power pin {conn.from_pin} not found on {from_ref} (tried normalization)")
                elif is_power_from and to_ref in pin_positions:
                    # Connection from power rail to component (e.g., PWR.VCC -> U1.VDD)
                    pin_pos, resolved_pin = find_pin_position(to_ref, conn.to_pin)
                    if pin_pos:
                        label_text = conn.net_name or conn.from_pin or "VCC"
                        # Place power label at the pin position
                        sheet.labels.append(Label(
                            text=label_text,
                            position=(pin_pos[0] + 2.54, pin_pos[1]),
                            rotation=0,
                            label_type="global_label"
                        ))
                        power_labels_added.append(f"{to_ref}.{conn.to_pin} -> {label_text}")
                    else:
                        logger.warning(f"Power pin {conn.to_pin} not found on {to_ref} (tried normalization)")
                continue  # Don't try to route wire for power connections

            # Regular connection - validate both ends exist
            issues = []
            resolved_from_pin = conn.from_pin
            resolved_to_pin = conn.to_pin

            if from_ref not in pin_positions:
                issues.append(f"from_ref '{from_ref}' not found")
            else:
                pos, resolved = find_pin_position(from_ref, conn.from_pin)
                if pos is None:
                    issues.append(f"from_pin '{conn.from_pin}' not found on {from_ref}")
                else:
                    resolved_from_pin = resolved

            if to_ref not in pin_positions:
                issues.append(f"to_ref '{to_ref}' not found")
            else:
                pos, resolved = find_pin_position(to_ref, conn.to_pin)
                if pos is None:
                    issues.append(f"to_pin '{conn.to_pin}' not found on {to_ref}")
                else:
                    resolved_to_pin = resolved

            if issues:
                invalid_connections.append({
                    "net": conn.net_name,
                    "from": f"{from_ref}.{conn.from_pin}",
                    "to": f"{to_ref}.{conn.to_pin}",
                    "issues": issues
                })
                logger.warning(f"Connection {conn.net_name}: {'; '.join(issues)}")
                continue

            conn_dicts.append({
                "from_ref": from_ref,
                "from_pin": resolved_from_pin,  # Use resolved pin name
                "to_ref": to_ref,
                "to_pin": resolved_to_pin,  # Use resolved pin name
                "net_name": conn.net_name or f"Net-({from_ref}-{resolved_from_pin})"
            })
            valid_connections += 1
            if resolved_from_pin != conn.from_pin or resolved_to_pin != conn.to_pin:
                logger.info(f"Pin name resolved: {conn.from_pin}->{resolved_from_pin}, {conn.to_pin}->{resolved_to_pin}")

        if power_labels_added:
            logger.info(f"Added {len(power_labels_added)} power labels: {power_labels_added[:5]}")

        # VALIDATION: Check if any connections remain (allow if we added power labels)
        if not conn_dicts and not power_labels_added:
            error_msg = (
                f"CRITICAL: No valid connections after filtering. "
                f"Original: {len(connections)}, Valid: 0. "
                f"Check that BOM references match connection references."
            )
            logger.error(error_msg)
            if invalid_connections:
                logger.error(f"Sample invalid connections: {invalid_connections[:5]}")
            raise ValueError(error_msg)

        logger.info(f"Connection validation: {valid_connections} valid of {len(connections)} total")

        # ========================================
        # ROUTE WIRES (only if we have non-power connections)
        # ========================================

        if conn_dicts:
            result = self.enhanced_router.route(
                conn_dicts,
                component_positions,
                pin_positions,
                sheet_bounds=(0, 0, self.DEFAULT_SHEET_SIZE[0], self.DEFAULT_SHEET_SIZE[1])
            )

            # ========================================
            # POST-ROUTING VALIDATION
            # ========================================

            # VALIDATION: Check if wires were generated
            if not result.wires:
                error_msg = (
                    f"CRITICAL: Wire router returned 0 wires for {len(conn_dicts)} connections. "
                    f"This indicates a routing algorithm failure."
                )
                logger.error(error_msg)
                raise ValueError(error_msg)
        else:
            # Only power labels, no wires needed - this is a WARNING condition
            # because it usually indicates the LLM connection generator failed
            warning_msg = (
                f"SKIPPING wire routing: No non-power connections to route. "
                f"Total connections provided: {len(connections)}, "
                f"Non-power connections after filtering: 0. "
                f"Power labels added: {len(power_labels_added)}. "
                f"Schematic will have 0 signal wires (only power labels). "
                f"This often indicates LLM connection generation failed upstream."
            )
            logger.warning(warning_msg)
            result = type('RouterResult', (), {'wires': [], 'junctions': [], 'four_way_junctions_avoided': 0})()

        # VALIDATION: Check wire-to-connection ratio (only if we have connections to route)
        # This is a CRITICAL quality gate - a schematic with <50% wire coverage is non-functional
        if conn_dicts:
            wire_connection_ratio = len(result.wires) / len(conn_dicts)
            if wire_connection_ratio < 0.5:
                # CRITICAL FAILURE: Reject schematics that would be non-functional
                error_details = {
                    "wires_generated": len(result.wires),
                    "connections_required": len(conn_dicts),
                    "coverage_ratio": f"{wire_connection_ratio:.1%}",
                    "missing_connections": len(conn_dicts) - len(result.wires),
                    "possible_causes": [
                        "Missing pin positions in symbol definitions",
                        "Component reference mismatches between BOM and connections",
                        "Wire router algorithm limitations with complex layouts",
                        "Overlapping component placements blocking wire paths"
                    ]
                }
                error_msg = (
                    f"CRITICAL: Wire routing failed - only {wire_connection_ratio:.1%} of connections routed. "
                    f"Generated {len(result.wires)} wires for {len(conn_dicts)} required connections. "
                    f"This schematic would be non-functional and cannot be exported. "
                    f"Minimum required coverage: 50%. "
                    f"Check component symbol pin definitions and connection specifications."
                )
                logger.error(error_msg)
                raise SchematicAssemblyError(error_msg, error_details)
            elif wire_connection_ratio < 0.8:
                # Warning only for 50-80% coverage - schematic may work but has issues
                logger.warning(
                    f"Wire routing incomplete: {wire_connection_ratio:.1%} coverage. "
                    f"Generated {len(result.wires)} wires for {len(conn_dicts)} connections. "
                    f"Schematic may have missing connections - manual review recommended."
                )
            else:
                logger.info(
                    f"Wire routing successful: {wire_connection_ratio:.1%} coverage "
                    f"({len(result.wires)} wires for {len(conn_dicts)} connections)"
                )

        # Convert results to schematic format
        for wire_seg in result.wires:
            sheet.wires.append(Wire(
                start=wire_seg.start,
                end=wire_seg.end,
                uuid=wire_seg.uuid
            ))

        for junc in result.junctions:
            sheet.junctions.append(Junction(
                position=junc.position,
                uuid=junc.uuid
            ))

        # Add net labels for named nets
        added_labels = set()
        for conn in connections:
            if conn.net_name and not conn.net_name.startswith("Net-"):
                if conn.net_name in added_labels:
                    continue
                added_labels.add(conn.net_name)

                from_sym = symbol_map.get(conn.from_ref)
                to_sym = symbol_map.get(conn.to_ref)

                if from_sym and to_sym:
                    from_pos = from_sym.get_absolute_pin_position(conn.from_pin) or from_sym.position
                    to_pos = to_sym.get_absolute_pin_position(conn.to_pin) or to_sym.position

                    mid_x = (from_pos[0] + to_pos[0]) / 2
                    mid_y = (from_pos[1] + to_pos[1]) / 2
                    sheet.labels.append(Label(
                        text=conn.net_name,
                        position=(mid_x, mid_y)
                    ))

        logger.info(
            f"Enhanced routing complete: {len(sheet.wires)} wires, "
            f"{len(sheet.junctions)} junctions, "
            f"{result.four_way_junctions_avoided} 4-way junctions avoided"
        )

        # ========================================
        # LLM-BASED SEMANTIC VALIDATION (Optional)
        # ========================================
        if self._openrouter_api_key and len(sheet.wires) > 0:
            await self._validate_routing_with_llm(sheet, connections, valid_connections)

    async def _validate_routing_with_llm(
        self,
        sheet: SchematicSheet,
        connections: List[Connection],
        valid_connection_count: int
    ):
        """
        Use LLM to semantically validate the wire routing.

        AI-first approach: Uses Claude Opus 4.6 to analyze the routing and
        identify potential issues that simple structural checks might miss.
        """
        if self._http_client is None:
            self._http_client = httpx.AsyncClient(timeout=60.0)

        # Build summary of routing for LLM analysis
        wire_summary = []
        for i, wire in enumerate(sheet.wires[:50]):  # Limit to first 50 for token efficiency
            wire_summary.append(f"Wire {i+1}: ({wire.start[0]:.2f}, {wire.start[1]:.2f}) → ({wire.end[0]:.2f}, {wire.end[1]:.2f})")

        connection_summary = []
        for conn in connections[:30]:  # Limit to first 30
            connection_summary.append(
                f"{conn.from_ref}.{conn.from_pin} → {conn.to_ref}.{conn.to_pin} ({conn.net_name or 'unnamed'})"
            )

        component_summary = []
        for sym in sheet.symbols[:20]:  # Limit to first 20
            pin_count = len(sym.pins)
            component_summary.append(f"{sym.reference}: {sym.part_number} ({pin_count} pins) at ({sym.position[0]:.1f}, {sym.position[1]:.1f})")

        prompt = f"""You are an expert electronics engineer validating schematic wire routing.

Analyze this routing and identify any CRITICAL issues. Focus on:
1. Missing power connections (VCC/GND not connected to ICs)
2. Floating pins on critical components
3. Obvious short circuits or crossed wires
4. Components that appear to be isolated (no connections)

SCHEMATIC SUMMARY:
- Total Components: {len(sheet.symbols)}
- Total Wires: {len(sheet.wires)}
- Total Connections Attempted: {len(connections)}
- Valid Connections Routed: {valid_connection_count}

COMPONENTS:
{chr(10).join(component_summary)}

CONNECTIONS:
{chr(10).join(connection_summary)}

WIRE SEGMENTS (first 50):
{chr(10).join(wire_summary)}

Return a JSON object with:
{{
  "validation_passed": true/false,
  "critical_issues": ["list of critical issues found"],
  "warnings": ["list of non-critical warnings"],
  "recommendations": ["list of recommendations"]
}}

If everything looks reasonable, set validation_passed to true with empty issues.
Return ONLY the JSON, no explanations."""

        try:
            response = await self._http_client.post(
                OPENROUTER_BASE_URL,
                headers={
                    "Authorization": f"Bearer {self._openrouter_api_key}",
                    "Content-Type": "application/json",
                    "HTTP-Referer": "https://nexus.adverant.com",
                    "X-Title": "Nexus EE Design - Routing Validation"
                },
                json={
                    "model": OPENROUTER_MODEL,
                    "messages": [
                        {"role": "system", "content": "You are an expert electronics engineer. Analyze schematic routing and return structured JSON validation results."},
                        {"role": "user", "content": prompt}
                    ],
                    "temperature": 0.0,
                    "max_tokens": 2000
                }
            )
            response.raise_for_status()
            result = response.json()

            content = result["choices"][0]["message"]["content"].strip()

            # Clean up JSON if wrapped in code block
            if content.startswith("```"):
                lines = content.split("\n")
                content = "\n".join(lines[1:-1] if lines[-1].startswith("```") else lines[1:])

            validation_result = json.loads(content)

            if validation_result.get("validation_passed"):
                logger.info("LLM routing validation: PASSED")
            else:
                logger.warning("LLM routing validation: ISSUES FOUND")
                for issue in validation_result.get("critical_issues", []):
                    logger.warning(f"  CRITICAL: {issue}")
                for warning in validation_result.get("warnings", []):
                    logger.warning(f"  WARNING: {warning}")

            # Store validation results for later use
            sheet.metadata = sheet.metadata or {}
            sheet.metadata["llm_routing_validation"] = validation_result

        except json.JSONDecodeError as e:
            logger.warning(f"LLM routing validation returned invalid JSON: {e}")
        except Exception as e:
            logger.warning(f"LLM routing validation failed (non-critical): {e}")

    def _manhattan_route(
        self,
        start: Tuple[float, float],
        end: Tuple[float, float]
    ) -> List[Wire]:
        """Create Manhattan (orthogonal) routing between two points."""
        wires = []
        sx, sy = start
        ex, ey = end

        # Snap to grid
        sx = round(sx / self.GRID_UNIT) * self.GRID_UNIT
        sy = round(sy / self.GRID_UNIT) * self.GRID_UNIT
        ex = round(ex / self.GRID_UNIT) * self.GRID_UNIT
        ey = round(ey / self.GRID_UNIT) * self.GRID_UNIT

        # Simple L-route: horizontal then vertical
        if abs(sx - ex) > 0.01:
            wires.append(Wire(start=(sx, sy), end=(ex, sy)))

        if abs(sy - ey) > 0.01:
            wires.append(Wire(start=(ex, sy), end=(ex, ey)))

        return wires

    def _add_junctions(self, sheet: SchematicSheet):
        """Add junction dots at wire intersections."""
        # Track endpoints
        endpoints: Dict[Tuple[float, float], int] = {}

        for wire in sheet.wires:
            for point in [wire.start, wire.end]:
                # Round for comparison
                key = (round(point[0], 2), round(point[1], 2))
                endpoints[key] = endpoints.get(key, 0) + 1

        # Add junctions where 3+ wires meet
        for point, count in endpoints.items():
            if count >= 3:
                sheet.junctions.append(Junction(position=point))

    def _add_power_symbols(self, sheet: SchematicSheet):
        """Add power symbols (VCC, GND) as needed."""
        # Find power pins and add appropriate symbols
        for symbol in sheet.symbols:
            for pin in symbol.pins:
                if pin.pin_type == PinType.POWER_IN:
                    # Add power flag or symbol
                    pin_pos = symbol.get_absolute_pin_position(pin.name)
                    if pin_pos:
                        name_lower = pin.name.lower()
                        if "gnd" in name_lower or "vss" in name_lower:
                            sheet.labels.append(Label(
                                text="GND",
                                position=pin_pos,
                                label_type="global_label"
                            ))
                        elif "vcc" in name_lower or "vdd" in name_lower:
                            sheet.labels.append(Label(
                                text="VCC",
                                position=pin_pos,
                                label_type="global_label"
                            ))

    def _generate_placeholder_lib_symbol(self, symbol_id: str) -> str:
        """
        Generate a placeholder lib_symbol definition for KiCanvas compatibility.

        When a symbol definition is missing, KiCanvas crashes. This generates
        a minimal valid symbol definition to prevent crashes while making it
        obvious the symbol needs to be replaced.

        Uses KiCad 8.x tab indentation format.
        """
        # Escape quotes in symbol_id
        safe_id = symbol_id.replace('"', '\\"')

        # NOTE: This placeholder is inserted into lib_symbols with additional \t\t prefix
        # So the base indentation here should be minimal (relative to lib_symbols context)
        return f'''(symbol "{safe_id}" (in_bom yes) (on_board yes)
\t(property "Reference" "?" (at 0 1.27 0)
\t\t(effects (font (size 1.27 1.27)))
\t)
\t(property "Value" "{safe_id} [MISSING]" (at 0 -1.27 0)
\t\t(effects (font (size 1.27 1.27)))
\t)
\t(property "Footprint" "" (at 0 0 0)
\t\t(effects (font (size 1.27 1.27)) hide)
\t)
\t(property "Datasheet" "~" (at 0 0 0)
\t\t(effects (font (size 1.27 1.27)) hide)
\t)
\t(symbol "{safe_id}_0_1"
\t\t(rectangle (start -5.08 5.08) (end 5.08 -5.08)
\t\t\t(stroke (width 0.254) (type default))
\t\t\t(fill (type background))
\t\t)
\t\t(text "?" (at 0 0 0)
\t\t\t(effects (font (size 3.81 3.81)))
\t\t)
\t)
\t(symbol "{safe_id}_1_1"
\t\t(pin passive line (at -7.62 2.54 0) (length 2.54)
\t\t\t(name "1" (effects (font (size 1.27 1.27))))
\t\t\t(number "1" (effects (font (size 1.27 1.27))))
\t\t)
\t\t(pin passive line (at -7.62 0 0) (length 2.54)
\t\t\t(name "2" (effects (font (size 1.27 1.27))))
\t\t\t(number "2" (effects (font (size 1.27 1.27))))
\t\t)
\t\t(pin passive line (at 7.62 2.54 180) (length 2.54)
\t\t\t(name "3" (effects (font (size 1.27 1.27))))
\t\t\t(number "3" (effects (font (size 1.27 1.27))))
\t\t)
\t\t(pin passive line (at 7.62 0 180) (length 2.54)
\t\t\t(name "4" (effects (font (size 1.27 1.27))))
\t\t\t(number "4" (effects (font (size 1.27 1.27))))
\t\t)
\t)
)'''

    async def _extract_inner_symbol(self, sexp: str, symbol_id: str) -> Optional[str]:
        """
        Extract the inner symbol definition from a kicad_symbol_lib wrapper using LLM.

        AI-first approach: Uses Claude Opus 4.6 to intelligently identify and extract
        the primary symbol definition from a KiCad symbol library S-expression.

        The input format is:
        (kicad_symbol_lib (version ...) (generator ...)
          (symbol "NAME" ...)
        )

        We need to extract just the (symbol "NAME" ...) part.
        """
        if not self._openrouter_api_key:
            logger.warning("OpenRouter API key not set - cannot extract symbol via LLM")
            return None

        # Initialize HTTP client if needed
        if self._http_client is None:
            self._http_client = httpx.AsyncClient(timeout=60.0)

        prompt = f"""You are a KiCad S-expression parser. Extract the PRIMARY symbol definition from this symbol library.

Task: Extract the complete (symbol "NAME" ...) block for symbol ID "{symbol_id}" or the closest matching primary symbol.

Rules:
1. Find the PRIMARY symbol definition (not sub-symbols like _0_1, _1_1, etc.)
2. Extract the COMPLETE symbol block including ALL nested content (properties, pins, shapes, sub-symbols)
3. The block starts with (symbol "NAME" and includes all matching closing parentheses
4. Replace tabs with 2 spaces in the output
5. Return ONLY the extracted S-expression, no explanations

Example output format:
(symbol "STM32G431CBT6" (in_bom yes) (on_board yes)
  (property "Reference" "U" ...)
  ...
)

S-expression to parse:
```
{sexp[:8000]}
```

Return ONLY the extracted (symbol ...) block:"""

        try:
            response = await self._http_client.post(
                OPENROUTER_BASE_URL,
                headers={
                    "Authorization": f"Bearer {self._openrouter_api_key}",
                    "Content-Type": "application/json",
                    "HTTP-Referer": "https://nexus.adverant.com",
                    "X-Title": "Nexus EE Design - Symbol Extraction"
                },
                json={
                    "model": OPENROUTER_MODEL,
                    "messages": [
                        {"role": "system", "content": "You are a precise KiCad S-expression parser. Extract complete symbol blocks preserving all nested structures. Return only the requested S-expression, no explanations."},
                        {"role": "user", "content": prompt}
                    ],
                    "temperature": 0.0,
                    "max_tokens": 8000
                }
            )
            response.raise_for_status()
            result = response.json()

            content = result["choices"][0]["message"]["content"].strip()

            # Clean up code blocks if present
            if content.startswith("```"):
                lines = content.split("\n")
                content = "\n".join(lines[1:-1] if lines[-1].startswith("```") else lines[1:])

            # Ensure it starts with (symbol
            content = content.strip()
            if not content.startswith("(symbol"):
                logger.warning(f"LLM extraction did not return valid symbol: {content[:100]}")
                return None

            # Replace tabs with spaces
            content = content.replace('\t', '  ')

            logger.debug(f"LLM extracted symbol definition ({len(content)} chars)")
            return content

        except Exception as e:
            logger.error(f"LLM symbol extraction failed: {e}")
            return None

    @staticmethod
    def _normalize_sym_to_sch_format(sym_content: str) -> str:
        """Normalize .kicad_sym boolean flags to .kicad_sch lib_symbols format.

        KiCad library files (.kicad_sym) use (hide yes), (italic yes), (bold yes) as
        sub-expressions, but when embedded in a .kicad_sch lib_symbols section, kicad-cli
        8.x expects bare tokens: hide, italic, bold.

        Transforms:
          (pin_numbers (hide yes))    -> (pin_numbers hide)
          (pin_names (offset X) (hide yes)) -> (pin_names (offset X) hide)
          (pin_names (offset X))  (multiline) -> (pin_names (offset X))  (single line)
          (italic yes)                -> italic   (inside font)
          (bold yes)                  -> bold     (inside font)
          (pin ... (hide yes) ...)    -> (pin ... hide ...)  (hidden pins)
        """
        # 1. pin_numbers: multiline (pin_numbers\n(hide yes)\n) -> (pin_numbers hide)
        sym_content = re.sub(
            r'\(pin_numbers\s*\n\s*\(hide\s+yes\)\s*\n\s*\)',
            '(pin_numbers hide)',
            sym_content,
        )
        # 2. pin_names with (hide yes): collapse to single line with bare hide
        sym_content = re.sub(
            r'\(pin_names\s*\n\s*(\(offset\s+[\d.]+\))\s*\n\s*\(hide\s+yes\)\s*\n\s*\)',
            r'(pin_names \1 hide)',
            sym_content,
        )
        # 3. pin_names multiline without hide: collapse to single line
        sym_content = re.sub(
            r'\(pin_names\s*\n\s*(\(offset\s+[\d.]+\))\s*\n\s*\)',
            r'(pin_names \1)',
            sym_content,
        )
        # 4. (italic yes) -> italic (bare token in font context)
        sym_content = re.sub(r'\(italic\s+yes\)', 'italic', sym_content)
        # 5. (bold yes) -> bold (bare token in font context)
        sym_content = re.sub(r'\(bold\s+yes\)', 'bold', sym_content)
        # 6. (hide yes) inside pin definitions (appears after (length ...), before (name ...))
        sym_content = re.sub(
            r'(\(length\s+[\d.]+\))\s*\n(\s*)\(hide\s+yes\)',
            r'\1\n\2hide',
            sym_content,
        )
        return sym_content

    def _extract_inner_symbol_deterministic(self, sexp: str) -> Optional[str]:
        """Extract inner (symbol ...) block from kicad_symbol_lib wrapper using paren counting.

        Deterministic replacement for _extract_inner_symbol() — no LLM calls, no truncation,
        handles symbols of any size (including 80K+ char MCU definitions).
        """
        # Find the first (symbol " token after any (kicad_symbol_lib ...) wrapper
        start_idx = sexp.find('(symbol "')
        if start_idx == -1:
            return None

        # Count parentheses to find the matching close
        depth = 0
        in_string = False
        escape_next = False
        for i in range(start_idx, len(sexp)):
            ch = sexp[i]
            if escape_next:
                escape_next = False
                continue
            if ch == '\\':
                escape_next = True
                continue
            if ch == '"':
                in_string = not in_string
                continue
            if in_string:
                continue
            if ch == '(':
                depth += 1
            elif ch == ')':
                depth -= 1
                if depth == 0:
                    return sexp[start_idx:i+1]
        return None

    def _normalize_to_tabs(self, content: str, base_indent: int = 2) -> str:
        """
        Normalize all indentation in S-expression content to use tabs only.

        KiCad 8.x requires PURE TAB indentation - mixed tabs and spaces cause
        "Failed to load schematic file" errors in kicad-cli.

        This function:
        1. Detects leading whitespace on each line
        2. Counts indentation level (spaces converted: 2 or 4 spaces = 1 level)
        3. Replaces all leading whitespace with tabs at detected level + base_indent

        Args:
            content: S-expression content with potentially mixed indentation
            base_indent: Number of tabs to add as base indentation (default 2)

        Returns:
            Content with pure tab indentation
        """
        import re
        lines = content.split("\n")
        normalized = []

        for line in lines:
            if not line.strip():
                # Empty line or whitespace-only - emit truly empty line
                # KiCad 8.x rejects lines containing only tabs
                normalized.append("")
                continue

            # Count leading whitespace and convert to indent level
            # Handle both tabs and spaces
            match = re.match(r'^([\t ]*)', line)
            if match:
                leading = match.group(1)
                # Convert to indent level: each tab = 1, each 2-4 spaces = 1
                tab_count = leading.count('\t')
                space_count = leading.count(' ')
                # Assume 2-space or 4-space indentation
                space_levels = space_count // 2 if space_count % 4 != 0 else space_count // 4
                indent_level = tab_count + space_levels

                # Apply base indent + detected level
                total_tabs = base_indent + indent_level
                normalized.append("\t" * total_tabs + line.lstrip())
            else:
                normalized.append("\t" * base_indent + line)

        return "\n".join(normalized)

    def _validate_sexpression(self, content: str) -> tuple[bool, str]:
        """
        Validate S-expression parentheses balance.

        This is a CRITICAL validation step that catches malformed KiCad schematic
        output BEFORE it reaches the export pipeline. Unbalanced parentheses
        cause KiCad to fail silently or crash.

        Args:
            content: The S-expression string to validate

        Returns:
            Tuple of (is_valid, diagnostic_message)
            - If valid: (True, "Opens=N, Closes=N, max_depth=M")
            - If invalid: (False, detailed error with context)
        """
        open_count = 0
        close_count = 0
        max_depth = 0
        current_depth = 0
        in_string = False
        escape_next = False

        for i, char in enumerate(content):
            # Handle string literals - parentheses inside strings don't count
            if escape_next:
                escape_next = False
                continue
            if char == '\\':
                escape_next = True
                continue
            if char == '"':
                in_string = not in_string
                continue

            if in_string:
                continue

            if char == '(':
                open_count += 1
                current_depth += 1
                max_depth = max(max_depth, current_depth)
            elif char == ')':
                close_count += 1
                current_depth -= 1
                if current_depth < 0:
                    # Found unbalanced close parenthesis - provide context
                    start = max(0, i - 100)
                    end = min(len(content), i + 100)
                    context = content[start:end]
                    # Find the line number
                    line_num = content[:i].count('\n') + 1
                    return False, (
                        f"CRITICAL: Unbalanced S-expression at position {i} (line {line_num}). "
                        f"Extra closing parenthesis found. "
                        f"Opens so far: {open_count}, Closes so far: {close_count}. "
                        f"Context (200 chars around error): ...{context}..."
                    )

        if open_count != close_count:
            difference = close_count - open_count
            # Find potential problem areas - look for common patterns
            problem_hints = []
            if ')))' in content:
                problem_hints.append("Multiple consecutive closing parens detected")
            if content.count('(symbol') != content.count('  )') // 2:
                problem_hints.append("Symbol block count mismatch suspected")

            return False, (
                f"CRITICAL: S-expression parentheses mismatch. "
                f"Opens: {open_count}, Closes: {close_count}, "
                f"Difference: {difference} {'extra closes' if difference > 0 else 'missing closes'}. "
                f"Max nesting depth reached: {max_depth}. "
                f"Content length: {len(content)} chars. "
                f"Hints: {'; '.join(problem_hints) if problem_hints else 'None'}. "
                f"This indicates a bug in S-expression generation - check _symbol_to_sexp, "
                f"_generate_placeholder_lib_symbol, or generate_kicad_sch methods."
            )

        return True, f"Opens={open_count}, Closes={close_count}, max_depth={max_depth}"

    async def generate_kicad_sch(self, sheet: SchematicSheet) -> str:
        """Generate KiCad S-expression schematic file in KiCad 8.x format."""
        # Build the schematic file with proper KiCad 8.x format
        # NOTE: KiCad 8.x requires tab indentation and generator_version
        lines = [
            "(kicad_sch",
            "\t(version 20231120)",
            "\t(generator \"nexus_ee_design\")",
            "\t(generator_version \"8.0\")",
            f"\t(uuid \"{sheet.uuid}\")",
            "\t(paper \"A4\")",
        ]

        # Add lib_symbols section with tab indentation for KiCad 8.x compatibility
        # CRITICAL: KiCad 8.x requires PURE TAB indentation - mixed tabs/spaces fail
        lines.append("\t(lib_symbols")
        for symbol_id, sexp in sheet.lib_symbols.items():
            # Extract just the symbol definition from the library wrapper (deterministic parser)
            symbol_content = self._extract_inner_symbol_deterministic(sexp)
            if symbol_content:
                # CRITICAL: Strip (embedded_fonts ...) from symbol definitions.
                # Cached .kicad_sym files include this property, but it's NOT valid
                # inside the lib_symbols section of a .kicad_sch file. kicad-cli will
                # reject the schematic with "Failed to load schematic file" if present.
                symbol_content = re.sub(
                    r'\s*\(embedded_fonts\s+\w+\)', '', symbol_content
                )
                # CRITICAL: Normalize .kicad_sym boolean flags to .kicad_sch format.
                # Cached .kicad_sym files use (hide yes), (italic yes), (bold yes) as
                # sub-expressions, but kicad-cli expects bare tokens hide/italic/bold
                # in pin_numbers, pin_names, pin defs, and font contexts.
                symbol_content = self._normalize_sym_to_sch_format(symbol_content)
                # SAFETY NET: Ensure the extracted symbol's internal name matches the dict key.
                # If the fetcher returned e.g. a generic "R" symbol but the instance references
                # the part number "C2012X7R1E104K", kicad-cli would fail to find the definition.
                internal_name = self._extract_symbol_name_deterministic(symbol_content)
                if internal_name and internal_name != symbol_id:
                    logger.warning(
                        f"lib_symbol name mismatch: internal='{internal_name}' vs expected='{symbol_id}'. "
                        f"Renaming symbol in sexp to match instance lib_id."
                    )
                    symbol_content = self._rename_symbol_in_sexp(symbol_content, internal_name, symbol_id)
                # Normalize to pure tab indentation (base_indent=2 for inside lib_symbols)
                normalized = self._normalize_to_tabs(symbol_content, base_indent=2)
                lines.append(normalized)
            else:
                # Generate a placeholder lib_symbol to prevent KiCanvas crashes
                logger.warning(f"Missing lib_symbol for {symbol_id}, generating placeholder")
                placeholder = self._generate_placeholder_lib_symbol(symbol_id)
                # Normalize placeholder as well
                normalized = self._normalize_to_tabs(placeholder, base_indent=2)
                lines.append(normalized)
        lines.append("\t)")

        # Add symbol instances
        for symbol in sheet.symbols:
            lines.append(self._symbol_to_sexp(symbol))
            lines.append("")

        # Add wires
        for wire in sheet.wires:
            lines.append(self._wire_to_sexp(wire))

        # Add junctions with tab indentation
        for junction in sheet.junctions:
            lines.append(f'\t(junction (at {junction.position[0]} {junction.position[1]}) (diameter 0) (color 0 0 0 0)\n\t\t(uuid "{junction.uuid}")\n\t)')

        # Add labels
        for label in sheet.labels:
            lines.append(self._label_to_sexp(label))

        # Add sheet_instances section (required for KiCad 8)
        lines.append("\t(sheet_instances")
        lines.append('\t\t(path "/" (page "1"))')
        lines.append("\t)")

        # Add symbol_instances section (required for KiCad 8 to count components)
        lines.append("\t(symbol_instances")
        for symbol in sheet.symbols:
            lines.append(f'\t\t(path "/{symbol.uuid}"')
            lines.append(f'\t\t\t(reference "{symbol.reference}") (unit {symbol.unit})')
            lines.append('\t\t)')
        lines.append("\t)")

        lines.append(")")

        # Assemble the final content
        kicad_content = "\n".join(lines)

        # CRITICAL VALIDATION: Ensure S-expression is well-formed before returning
        # This catches malformed output that would cause KiCad to fail silently
        is_valid, diagnostic_msg = self._validate_sexpression(kicad_content)
        if not is_valid:
            logger.error(f"Generated schematic has invalid S-expression: {diagnostic_msg}")
            raise SchematicAssemblyError(
                f"Schematic generation produced malformed KiCad file. {diagnostic_msg}"
            )

        logger.info(f"S-expression validation PASSED: {diagnostic_msg}")
        return kicad_content

    def _symbol_to_sexp(self, symbol: SymbolInstance) -> str:
        """Convert symbol instance to S-expression with KiCad 8 format using tabs."""
        x, y = symbol.position

        # KiCad 8.x requires tab indentation and (instances ...) block inside each symbol
        return f'''\t(symbol (lib_id "{symbol.symbol_id}") (at {x} {y} {symbol.rotation}) (unit {symbol.unit})
\t\t(exclude_from_sim no) (in_bom yes) (on_board yes) (dnp no)
\t\t(uuid "{symbol.uuid}")
\t\t(property "Reference" "{symbol.reference}" (at {x} {y - 5} 0)
\t\t\t(effects (font (size 1.27 1.27)))
\t\t)
\t\t(property "Value" "{symbol.value}" (at {x} {y + 5} 0)
\t\t\t(effects (font (size 1.27 1.27)))
\t\t)
\t\t(property "Footprint" "{symbol.footprint}" (at {x} {y} 0)
\t\t\t(effects (font (size 1.27 1.27)) hide)
\t\t)
\t\t(property "Datasheet" "~" (at {x} {y} 0)
\t\t\t(effects (font (size 1.27 1.27)) hide)
\t\t)
\t\t(instances
\t\t\t(project ""
\t\t\t\t(path "/{symbol.uuid}"
\t\t\t\t\t(reference "{symbol.reference}")
\t\t\t\t\t(unit {symbol.unit})
\t\t\t\t)
\t\t\t)
\t\t)
\t)'''

    def _wire_to_sexp(self, wire: Wire) -> str:
        """Convert wire to S-expression with KiCad 8.x tab format."""
        sx, sy = wire.start
        ex, ey = wire.end
        return f'''\t(wire (pts (xy {sx} {sy}) (xy {ex} {ey}))
\t\t(stroke (width 0) (type default))
\t\t(uuid "{wire.uuid}")
\t)'''

    def _label_to_sexp(self, label: Label) -> str:
        """Convert label to S-expression with KiCad 8.x tab format."""
        x, y = label.position

        if label.label_type == "global_label":
            return f'''\t(global_label "{label.text}" (shape input) (at {x} {y} {label.rotation})
\t\t(effects (font (size 1.27 1.27)))
\t\t(uuid "{label.uuid}")
\t)'''
        else:
            return f'''\t(label "{label.text}" (at {x} {y} {label.rotation})
\t\t(effects (font (size 1.27 1.27)))
\t\t(uuid "{label.uuid}")
\t)'''


# CLI entry point
if __name__ == "__main__":
    import sys

    async def main():
        assembler = SchematicAssemblerAgent()

        # Create test BOM
        test_bom = [
            BOMItem(part_number="STM32G431CBT6", category="MCU", value="STM32G431"),
            BOMItem(part_number="DRV8323RS", category="Gate_Driver", value="DRV8323"),
            BOMItem(part_number="CSD19505KCS", category="MOSFET", value="80V/150A"),
            BOMItem(part_number="100uF", category="Capacitor", value="100uF"),
            BOMItem(part_number="10uF", category="Capacitor", value="10uF"),
            BOMItem(part_number="0.1uF", category="Capacitor", value="0.1uF"),
            BOMItem(part_number="10k", category="Resistor", value="10k"),
            BOMItem(part_number="1k", category="Resistor", value="1k"),
        ]

        # Create test connections
        test_connections = [
            Connection(from_ref="U1", from_pin="VCC", to_ref="C1", to_pin="1", net_name="VCC"),
            Connection(from_ref="U1", from_pin="GND", to_ref="C1", to_pin="2", net_name="GND"),
            Connection(from_ref="U2", from_pin="VCC", to_ref="C2", to_pin="1", net_name="VCC"),
        ]

        print("Assembling schematic...")
        sheets = await assembler.assemble_schematic(
            test_bom,
            connections=test_connections,
            design_name="test_foc_esc"
        )

        print(f"\nGenerated {len(sheets)} sheet(s)")

        for sheet in sheets:
            print(f"\nSheet: {sheet.name}")
            print(f"  Components: {len(sheet.symbols)}")
            print(f"  Wires: {len(sheet.wires)}")
            print(f"  Labels: {len(sheet.labels)}")

            # Generate output
            output = await assembler.generate_kicad_sch(sheet)
            output_path = Path(f"/tmp/{sheet.filename}")
            output_path.write_text(output)
            print(f"  Output: {output_path}")

    asyncio.run(main())
