"""
MAPO v2.1 Schematic State - Immutable Schematic Snapshots

Provides immutable data structures for representing schematic state
throughout the optimization pipeline. Designed for Gaming AI exploration
where mutations create new states rather than modifying existing ones.

Author: Nexus EE Design Team
"""

import copy
import hashlib
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

import numpy as np


class SymbolQuality(Enum):
    """Quality classification for resolved symbols."""
    VERIFIED = "verified"        # From official KiCad libraries
    FETCHED = "fetched"          # From external APIs (SnapEDA, UltraLibrarian)
    CACHED = "cached"            # From local cache
    LLM_GENERATED = "generated"  # Generated by LLM (needs review)
    PLACEHOLDER = "placeholder"  # Generic fallback (NOT production-ready)


class PinType(Enum):
    """KiCad pin electrical types."""
    INPUT = "input"
    OUTPUT = "output"
    BIDIRECTIONAL = "bidirectional"
    TRI_STATE = "tri_state"
    PASSIVE = "passive"
    POWER_IN = "power_in"
    POWER_OUT = "power_out"
    OPEN_COLLECTOR = "open_collector"
    OPEN_EMITTER = "open_emitter"
    NO_CONNECT = "no_connect"
    UNSPECIFIED = "unspecified"


@dataclass(frozen=True)
class Pin:
    """Immutable symbol pin definition."""
    name: str
    number: str
    pin_type: PinType
    position: Tuple[float, float]  # Relative to symbol origin (mm)
    orientation: int  # 0=right, 90=up, 180=left, 270=down
    length: float = 2.54  # mm


@dataclass(frozen=True)
class ComponentInstance:
    """
    Immutable placed component in schematic.
    
    Represents a single component instance with its symbol,
    placement, and resolution metadata.
    """
    uuid: str
    part_number: str
    manufacturer: str
    category: str
    reference: str  # U1, R1, C1, etc.
    value: str
    position: Tuple[float, float]  # (x, y) in mm
    rotation: int  # 0, 90, 180, 270 degrees
    mirror: bool = False
    unit: int = 1  # For multi-unit symbols
    
    # Symbol resolution
    symbol_id: str = ""  # Reference to lib_symbol
    footprint: str = ""
    quality: SymbolQuality = SymbolQuality.PLACEHOLDER
    resolution_source: str = ""  # e.g., "kicad_worker", "snapeda", "nexus_memory"
    
    # Pin information (populated after symbol resolution)
    pins: Tuple[Pin, ...] = field(default_factory=tuple)
    
    # BOM metadata
    description: str = ""
    subsystem: str = ""


@dataclass(frozen=True)
class Connection:
    """
    Immutable net connection between two pins.
    
    Represents the logical connection (not the physical wire routing).
    """
    from_ref: str  # Component reference (e.g., "U1")
    from_pin: str  # Pin name or number (e.g., "VCC" or "1")
    to_ref: str    # Target component reference
    to_pin: str    # Target pin name or number
    net_name: Optional[str] = None  # Named net (auto-generated if None)
    net_class: str = "Default"  # For DRC rules
    
    # Connection metadata
    connection_type: str = "signal"  # signal, power, ground, bus
    inferred: bool = False  # True if inferred by LLM rather than explicit


@dataclass(frozen=True)
class WireSegment:
    """
    Immutable wire segment (Manhattan routing).
    
    Represents a single segment of a wire (horizontal or vertical).
    """
    start: Tuple[float, float]  # (x, y) in mm
    end: Tuple[float, float]    # (x, y) in mm
    
    @property
    def is_horizontal(self) -> bool:
        return abs(self.start[1] - self.end[1]) < 0.01
    
    @property
    def is_vertical(self) -> bool:
        return abs(self.start[0] - self.end[0]) < 0.01
    
    @property
    def length(self) -> float:
        dx = self.end[0] - self.start[0]
        dy = self.end[1] - self.start[1]
        return (dx**2 + dy**2) ** 0.5


@dataclass(frozen=True)
class Wire:
    """
    Immutable wire path connecting two pins.
    
    Consists of one or more segments with junctions where needed.
    """
    net_name: str
    segments: Tuple[WireSegment, ...]
    from_ref: str
    from_pin: str
    to_ref: str
    to_pin: str
    
    @property
    def total_length(self) -> float:
        return sum(seg.length for seg in self.segments)
    
    @property
    def bend_count(self) -> int:
        return max(0, len(self.segments) - 1)


@dataclass(frozen=True)
class Junction:
    """Immutable wire junction point."""
    position: Tuple[float, float]  # (x, y) in mm
    net_name: str


@dataclass(frozen=True)
class ValidationResults:
    """
    Immutable validation results for a schematic state.
    
    Captures ERC violations, best practice adherence, and
    smoke test results.
    """
    # ERC Results
    erc_errors: Tuple[str, ...] = field(default_factory=tuple)
    erc_warnings: Tuple[str, ...] = field(default_factory=tuple)
    erc_passed: bool = False
    
    # Best Practice Results
    bp_violations: Tuple[str, ...] = field(default_factory=tuple)
    bp_score: float = 0.0  # 0-1
    
    # Smoke Test Results (SPICE simulation)
    smoke_test_passed: bool = False
    smoke_test_errors: Tuple[str, ...] = field(default_factory=tuple)
    dc_operating_points: Dict[str, float] = field(default_factory=dict)
    
    # Symbol Quality
    placeholder_count: int = 0
    verified_count: int = 0
    fetched_count: int = 0
    
    @property
    def total_errors(self) -> int:
        return len(self.erc_errors) + len(self.smoke_test_errors)
    
    @property
    def is_valid(self) -> bool:
        return self.erc_passed and self.smoke_test_passed and self.placeholder_count == 0


@dataclass(frozen=True)
class FitnessScores:
    """
    Immutable fitness scores for Gaming AI optimization.
    
    Multi-objective fitness based on:
    - Correctness (ERC + smoke test)
    - Wiring quality
    - Simulation results
    - Cost efficiency
    """
    correctness: float = 0.0  # 0-1 (ERC + connections)
    wiring: float = 0.0       # 0-1 (wire routing quality)
    simulation: float = 0.0   # 0-1 (smoke test results)
    cost: float = 0.0         # 0-1 (BOM cost efficiency)
    
    # Weights for combined fitness
    correctness_weight: float = 0.40
    wiring_weight: float = 0.30
    simulation_weight: float = 0.20
    cost_weight: float = 0.10
    
    @property
    def combined(self) -> float:
        """Weighted combined fitness score."""
        return (
            self.correctness * self.correctness_weight +
            self.wiring * self.wiring_weight +
            self.simulation * self.simulation_weight +
            self.cost * self.cost_weight
        )
    
    def to_vector(self) -> np.ndarray:
        """Convert to numpy array for optimization."""
        return np.array([
            self.correctness,
            self.wiring,
            self.simulation,
            self.cost
        ], dtype=np.float32)


@dataclass(frozen=True)
class SchematicState:
    """
    Immutable schematic state snapshot.
    
    Represents a complete schematic at a point in time, including
    components, connections, wires, and validation results.
    
    Being frozen (immutable), mutations create new states rather
    than modifying existing ones - essential for Gaming AI exploration.
    """
    # Identity
    uuid: str = field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    
    # Core schematic data
    components: Tuple[ComponentInstance, ...] = field(default_factory=tuple)
    connections: Tuple[Connection, ...] = field(default_factory=tuple)
    wires: Tuple[Wire, ...] = field(default_factory=tuple)
    junctions: Tuple[Junction, ...] = field(default_factory=tuple)
    
    # Library symbols (symbol_id -> KiCad S-expression)
    lib_symbols: Dict[str, str] = field(default_factory=dict)
    
    # Validation and fitness
    validation: Optional[ValidationResults] = None
    fitness: Optional[FitnessScores] = None
    
    # Metadata
    design_name: str = ""
    design_intent: str = ""
    sheet_name: str = "Main"
    
    # Optimization tracking
    iteration: int = 0
    parent_uuid: Optional[str] = None  # For tracking mutation lineage
    mutation_type: Optional[str] = None  # What mutation created this state
    
    def __hash__(self) -> int:
        """Hash based on structural content, not metadata."""
        content = (
            tuple(sorted((c.reference, c.part_number) for c in self.components)),
            tuple(sorted((c.from_ref, c.from_pin, c.to_ref, c.to_pin) for c in self.connections)),
        )
        return hash(content)
    
    @property
    def component_count(self) -> int:
        return len(self.components)
    
    @property
    def connection_count(self) -> int:
        return len(self.connections)
    
    @property
    def wire_count(self) -> int:
        return len(self.wires)
    
    @property
    def total_wire_length(self) -> float:
        return sum(w.total_length for w in self.wires)
    
    @property
    def placeholder_count(self) -> int:
        return sum(1 for c in self.components if c.quality == SymbolQuality.PLACEHOLDER)
    
    @property
    def wiring_completeness(self) -> float:
        """Fraction of connections that have been routed."""
        if not self.connections:
            return 1.0
        routed_pairs = set()
        for w in self.wires:
            routed_pairs.add((w.from_ref, w.from_pin, w.to_ref, w.to_pin))
        return len(routed_pairs) / len(self.connections)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "uuid": self.uuid,
            "timestamp": self.timestamp,
            "design_name": self.design_name,
            "component_count": self.component_count,
            "connection_count": self.connection_count,
            "wire_count": self.wire_count,
            "wiring_completeness": self.wiring_completeness,
            "iteration": self.iteration,
            "fitness": self.fitness.combined if self.fitness else 0.0,
        }
    
    def with_components(self, components: List[ComponentInstance]) -> "SchematicState":
        """Create new state with updated components."""
        return SchematicState(
            uuid=str(uuid.uuid4()),
            timestamp=datetime.now().isoformat(),
            components=tuple(components),
            connections=self.connections,
            wires=self.wires,
            junctions=self.junctions,
            lib_symbols=self.lib_symbols.copy(),
            validation=None,  # Invalidate validation
            fitness=None,     # Invalidate fitness
            design_name=self.design_name,
            design_intent=self.design_intent,
            sheet_name=self.sheet_name,
            iteration=self.iteration + 1,
            parent_uuid=self.uuid,
            mutation_type="component_update",
        )
    
    def with_connections(self, connections: List[Connection]) -> "SchematicState":
        """Create new state with updated connections."""
        return SchematicState(
            uuid=str(uuid.uuid4()),
            timestamp=datetime.now().isoformat(),
            components=self.components,
            connections=tuple(connections),
            wires=tuple(),  # Clear wires - need re-routing
            junctions=tuple(),
            lib_symbols=self.lib_symbols.copy(),
            validation=None,
            fitness=None,
            design_name=self.design_name,
            design_intent=self.design_intent,
            sheet_name=self.sheet_name,
            iteration=self.iteration + 1,
            parent_uuid=self.uuid,
            mutation_type="connection_update",
        )
    
    def with_wires(self, wires: List[Wire], junctions: List[Junction]) -> "SchematicState":
        """Create new state with updated wiring."""
        return SchematicState(
            uuid=str(uuid.uuid4()),
            timestamp=datetime.now().isoformat(),
            components=self.components,
            connections=self.connections,
            wires=tuple(wires),
            junctions=tuple(junctions),
            lib_symbols=self.lib_symbols.copy(),
            validation=None,
            fitness=None,
            design_name=self.design_name,
            design_intent=self.design_intent,
            sheet_name=self.sheet_name,
            iteration=self.iteration + 1,
            parent_uuid=self.uuid,
            mutation_type="wire_update",
        )
    
    def with_validation(self, validation: ValidationResults, fitness: FitnessScores) -> "SchematicState":
        """Create new state with validation results."""
        return SchematicState(
            uuid=self.uuid,  # Same UUID - just adding metadata
            timestamp=self.timestamp,
            components=self.components,
            connections=self.connections,
            wires=self.wires,
            junctions=self.junctions,
            lib_symbols=self.lib_symbols,
            validation=validation,
            fitness=fitness,
            design_name=self.design_name,
            design_intent=self.design_intent,
            sheet_name=self.sheet_name,
            iteration=self.iteration,
            parent_uuid=self.parent_uuid,
            mutation_type=self.mutation_type,
        )


@dataclass
class SchematicSolution:
    """
    Mutable wrapper for Gaming AI optimization.
    
    Wraps immutable SchematicState with behavioral descriptors
    and optimization metadata needed by MAP-Elites and Red Queen.
    """
    state: SchematicState
    
    # Behavioral descriptor (10D vector for MAP-Elites)
    behavior_descriptor: Optional[np.ndarray] = None
    
    # Optimization metadata
    generation: int = 0
    offspring_count: int = 0
    is_elite: bool = False
    elite_cell: Optional[Tuple[int, ...]] = None
    
    # Performance tracking
    evaluation_count: int = 0
    last_mutation: Optional[str] = None
    improvement_history: List[float] = field(default_factory=list)
    
    @property
    def fitness(self) -> float:
        """Combined fitness score."""
        if self.state.fitness:
            return self.state.fitness.combined
        return 0.0
    
    @property
    def is_valid(self) -> bool:
        """Check if solution passes all validation."""
        if self.state.validation:
            return self.state.validation.is_valid
        return False
    
    def clone(self) -> "SchematicSolution":
        """Create a deep copy for mutation."""
        return SchematicSolution(
            state=self.state,  # Immutable, no need to copy
            behavior_descriptor=self.behavior_descriptor.copy() if self.behavior_descriptor is not None else None,
            generation=self.generation + 1,
            offspring_count=0,
            is_elite=False,
            elite_cell=None,
            evaluation_count=0,
            last_mutation=None,
            improvement_history=self.improvement_history.copy(),
        )
    
    def record_improvement(self, new_fitness: float):
        """Record fitness improvement."""
        self.improvement_history.append(new_fitness)
        self.evaluation_count += 1
